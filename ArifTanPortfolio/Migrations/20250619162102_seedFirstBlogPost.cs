using System;
using Microsoft.EntityFrameworkCore.Migrations;

#nullable disable

namespace ArifTanPortfolio.Migrations
{
    /// <inheritdoc />
    public partial class seedFirstBlogPost : Migration
    {
        /// <inheritdoc />
        protected override void Up(MigrationBuilder migrationBuilder)
        {
            migrationBuilder.InsertData(
                table: "BlogPosts",
                columns: new[] { "Id", "Author", "AuthorEmail", "Category", "Content", "CreatedDate", "Excerpt", "FeaturedImage", "IsPublished", "MetaDescription", "MetaKeywords", "PublishedDate", "ReadTimeMinutes", "Slug", "Tags", "Title", "UpdatedDate", "ViewCount" },
                values: new object[] { 1, "Arif Tan", "ariftan7788@gmail.com", "Technical Tutorial", "# Building Enterprise WMS with Clean Architecture: Real-World Implementation\n\n        Leading the development of a multi-warehouse management system has been one of the most challenging and rewarding projects of my career. This post shares the practical lessons learned while implementing Clean Architecture and Domain-Driven Design in a real enterprise environment.\n\n        ## The Challenge\n\n        Our client needed a comprehensive warehouse management system that could:\n        - Handle multiple warehouse locations\n        - Support multi-client operations with data isolation  \n        - Provide real-time inventory tracking\n        - Scale for future warehouse network expansion\n        - Integrate with existing ERP systems\n\n        ## Clean Architecture in Practice\n\n        ### Domain Layer Design\n\n        The heart of our system lies in properly modeled domain entities:\n\n        ```csharp\n        public class WarehouseLocation : Entity\n        {\n            public LocationId Id { get; private set; }\n            public string LocationCode { get; private set; }\n            public ClientId ClientId { get; private set; }\n            public WarehouseId WarehouseId { get; private set; }\n            \n            private readonly List<InventoryItem> _inventoryItems = new();\n            public IReadOnlyList<InventoryItem> InventoryItems => _inventoryItems.AsReadOnly();\n            \n            public Result<InventoryItem> AddInventory(Product product, Quantity quantity, UserId userId)\n            {\n                if (quantity.IsZero())\n                    return Result.Failure<InventoryItem>(\"Quantity must be greater than zero\");\n                    \n                var inventoryItem = InventoryItem.Create(product, quantity, Id, userId);\n                _inventoryItems.Add(inventoryItem);\n                \n                AddDomainEvent(new InventoryAddedEvent(Id, product.Id, quantity));\n                \n                return Result.Success(inventoryItem);\n            }\n        }\n        ```\n\n        ### Application Layer Use Cases\n\n        ```csharp\n        public class TransferInventoryUseCase : ITransferInventoryUseCase\n        {\n            private readonly IWarehouseLocationRepository _locationRepository;\n            private readonly IInventoryTransferService _transferService;\n            private readonly IUnitOfWork _unitOfWork;\n            \n            public async Task<r> ExecuteAsync(TransferInventoryCommand command)\n            {\n                var sourceLocation = await _locationRepository.GetByIdAsync(command.SourceLocationId);\n                var targetLocation = await _locationRepository.GetByIdAsync(command.TargetLocationId);\n                \n                var transferResult = _transferService.TransferInventory(\n                    sourceLocation, \n                    targetLocation, \n                    command.ProductId, \n                    command.Quantity,\n                    command.UserId);\n                    \n                if (transferResult.IsFailure)\n                    return transferResult;\n                    \n                await _unitOfWork.SaveChangesAsync();\n                return Result.Success();\n            }\n        }\n        ```\n\n        ## Real-Time Updates with SignalR\n\n        One of the key requirements was real-time location grid updates for warehouse operators:\n\n        ```csharp\n        [Authorize]\n        public class WarehouseHub : Hub\n        {\n            public async Task JoinWarehouseGroup(string warehouseId)\n            {\n                await Groups.AddToGroupAsync(Context.ConnectionId, $\"warehouse_{warehouseId}\");\n            }\n            \n            public async Task NotifyLocationUpdate(string warehouseId, LocationUpdateDto update)\n            {\n                await Clients.Group($\"warehouse_{warehouseId}\")\n                    .SendAsync(\"LocationUpdated\", update);\n            }\n        }\n        ```\n\n        ## Multi-Tenant Architecture\n\n        Ensuring client data isolation was critical:\n\n        ```csharp\n        public class WarehouseLocationRepository : IWarehouseLocationRepository\n        {\n            private readonly ApplicationDbContext _context;\n            private readonly ICurrentUserService _currentUser;\n            \n            public async Task<List<WarehouseLocation>> GetByWarehouseAsync(WarehouseId warehouseId)\n            {\n                var clientId = _currentUser.GetClientId();\n                \n                return await _context.WarehouseLocations\n                    .Where(l => l.WarehouseId == warehouseId && l.ClientId == clientId)\n                    .ToListAsync();\n            }\n        }\n        ```\n\n        ## Performance Optimization\n\n        Strategic database indexing proved crucial for performance:\n\n        ```sql\n        CREATE INDEX IX_WarehouseLocation_ClientId_WarehouseId \n        ON WarehouseLocations (ClientId, WarehouseId);\n\n        CREATE INDEX IX_InventoryItem_LocationId_ProductId \n        ON InventoryItems (LocationId, ProductId) \n        INCLUDE (Quantity, LastUpdated);\n        ```\n\n        ## Key Lessons Learned\n\n        ### 1. Domain Modeling is Critical\n        Spending time upfront to understand the domain and model it correctly pays massive dividends. The domain model becomes the single source of truth for business rules.\n\n        ### 2. Clean Architecture Enables Flexibility\n        When requirements changed, our Clean Architecture made it relatively easy to adapt. Business logic stayed in the domain, and we could modify infrastructure without affecting core functionality.\n\n        ### 3. Real-time Features Need Careful Design\n        SignalR is powerful, but managing connections and state in a multi-tenant environment requires careful consideration of scalability and security.\n\n        ### 4. Performance Matters from Day One\n        Implementing performance monitoring and optimization early saves significant refactoring time later.\n\n        ## Technical Stack\n\n        - **Backend**: ASP.NET Core 8.0, Entity Framework Core\n        - **Architecture**: Clean Architecture, Domain-Driven Design\n        - **Real-time**: SignalR for live updates\n        - **Database**: PostgreSQL with strategic indexing\n        - **Cloud**: AWS (EC2, RDS, S3)\n        - **Frontend**: Tailwind CSS, JavaScript\n\n        ## Results\n\n        The system now successfully handles:\n        - Multiple warehouse locations with unified operations\n        - Real-time inventory tracking across the network\n        - Multi-client data isolation and security\n        - Scalable architecture ready for expansion\n\n        ## Conclusion\n\n        This project reinforced my belief that good architecture is not just about following patterns—it's about solving real business problems while building systems that can evolve with changing requirements.\n\n        The experience has prepared me well for tackling similar challenges at global technology companies, where scalable architecture and clean code are essential for success.\n\n        *Follow my blog for more insights about enterprise software development and my journey toward global technology companies.*", new DateTime(2025, 6, 16, 10, 0, 0, 0, DateTimeKind.Utc), "Deep dive into building enterprise warehouse management systems using Clean Architecture and Domain-Driven Design, with real-world examples and practical lessons learned from leading development teams.", "/images/blog/enterprise-wms-architecture.jpg", true, "Learn how to build enterprise warehouse management systems using Clean Architecture and Domain-Driven Design with real-world examples and lessons learned.", "Clean Architecture, Enterprise Software, WMS, DDD, ASP.NET Core, Multi-tenant", new DateTime(2025, 6, 16, 10, 0, 0, 0, DateTimeKind.Utc), 8, "building-enterprise-wms-clean-architecture-real-world", "Clean Architecture, DDD, Enterprise Software, ASP.NET Core, SignalR, Multi-tenant", "Building Enterprise WMS with Clean Architecture: Real-World Implementation", null, 0 });
        }

        /// <inheritdoc />
        protected override void Down(MigrationBuilder migrationBuilder)
        {
            migrationBuilder.DeleteData(
                table: "BlogPosts",
                keyColumn: "Id",
                keyValue: 1);
        }
    }
}
